# Hot100

## 归并排序

分为自顶向下和自顶向上的归并排序：https://www.cnblogs.com/nullzx/p/5968170.html

自顶向下的排序算法就是把数组元素不断的二分，直到子数组的元素个数为一个，因为这个时候子数组必定是已有序的，然后将两个有序的序列合并成一个新的有序的序列，两个新的有序序列又可以合并成另一个新的有序序列，以此类推，直到合并成一个有序的数组。

自底向上的归并排序算法的思想就是数组中先一个一个归并成两两有序的序列，两两有序的序列归并成四个四个有序的序列，然后四个四个有序的序列归并八个八个有序的序列，以此类推，直到，归并的长度大于整个数组的长度，此时整个数组有序。需要注意的是数组按照归并长度划分，最后一个子数组可能不满足长度要求，这个情况需要特殊处理。

自顶向下的归并排序算法一般用递归来实现，而自底向上可以用循环来实现。

链表排序一般使用自底向上的归并排序，时间O(nlogn)，空间O(1)



例题： 148


## 快速排序
用分治法，参考   https://www.runoob.com/w3cnote/quick-sort.html

例题： 215



## 网格类问题--图的遍历统计等
这类题型的共同思路讲解：
https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/
例题：200  
DFS和BFS的讲解:https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/





## 回溯问题

回溯时DFS的一种形式：

每次搜索一个分支，会首先记录当前节点的状态，尝试完某个分支后，把状态回溯到记录的状态，再去尝试另外的分支

**模板：**

```
huisu_DFS():
1.base Case:
2.For each possibility p
  a.记录：现在的状态
  b.递归：huisu_DFS(next_state)
  c.回溯：restore current state
```

可以画画图看有哪些结果

**例题：**

offer_38

