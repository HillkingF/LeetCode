# 图
## 图的遍历
### T133 克隆图

```
【题目】
给你无向连通图中一个节点的引用，请你返回该图的 深拷贝（克隆）。
图中的每个节点都包含它的值 val（int） 和其邻居的列表。
【测试用例】
输入：adjList = [[2,4],[1,3],[2,4],[1,3]]
输出：[[2,4],[1,3],[2,4],[1,3]]
解释：
图中有 4 个节点。
节点 1 的值是 1，它有两个邻居：节点 2 和 4 。
节点 2 的值是 2，它有两个邻居：节点 1 和 3 。
节点 3 的值是 3，它有两个邻居：节点 2 和 4 。
节点 4 的值是 4，它有两个邻居：节点 1 和 3 。
```

```
/** 【解题思路】
 * 如果传入的节点 无邻接点,则copy值创建对象并返回单节点
 * 如果这个节点在状态表中已经存在: 从map状态表中获取此节点并返回
 * 如果这是一个未被扫描的原节点:
 * - 首先创建一个新节点并 初始化值
 * - 在状态map中存放这个新节点
 * - 创建一个用于存放邻接节点的list. 然后遍历原节点的邻接节点:
 * ===== 邻接节点已经在map中存在,则直接从map邻接节点加入新的list
 * ===== 邻接节点不存在map中,则对这个邻接节点使用BFS进行深拷贝.BFS返回值是这个邻接节点深拷贝后的新节点
 *       将这个新节点也加入新list
 * ===== 原节点的所有邻接节点值都深拷贝并加入 新list后,完成这个原节点的拷贝
 * - 最后返回原节点
 */
 
 【用到的知识点】
 深度优先搜索
 图的定义
 Hashmap根据节点值存放节点，表示已经访问
 邻接表使用List<Node>存放
 也可以使用广度优先搜索[之后试一下:需要用到队列]
```

此外图的定义题目给出：

```java
// 定义节点
class Node {
    public int val;  // 这个节点的值
    public List<Node> neighbors;  //这个节点邻居节点的序号列表
    public Node() {   // 没有值默认为0
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {  // 传递值时创建一个空的邻接列表
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
```

## 拓扑排序

定义：

- 把一个 有向无环图 转成 线性的排序 就叫 **拓扑排序**。

步骤：

- 由AOV网构造拓扑序列的拓扑排序算法主要是循环执行以下两步，直到不存在入度为0的顶点为止。

- (1) 选择一个入度为0的顶点并输出之；

- (2) 从网中删除此顶点及所有[出边](https://baike.baidu.com/item/出边)。

[ ![img](img/adaf2edda3cc7cd9565490a03401213fb80e914a) ](https://baike.baidu.com/pic/拓扑排序/5223807/0/adaf2edda3cc7cd9565490a03401213fb80e914a?fr=lemma&ct=single)

- 循环结束后，若输出的顶点数小于网中的顶点数，则输出“有[回路](https://baike.baidu.com/item/回路/35792)”信息，否则输出的顶点序列就是一种拓扑[序列](https://baike.baidu.com/item/序列/1302588)。 [2] 

------

### T207

题解：https://leetcode-cn.com/problems/course-schedule/solution/bao-mu-shi-ti-jie-shou-ba-shou-da-tong-tuo-bu-pai-/

怎么判断能否修完所有课？

    BFS 结束时，如果仍有课的入度不为 0，无法被选，完成不了所有课。否则，能找到一种顺序把所有课上完。
    或者：用一个变量 count 记录入列的顶点个数，最后判断 count 是否等于总课程数。

```
【知识点】
拓扑排序
BFS  DFS
hashmap记录点及出度邻接表

【本题的解题思路】
[第一步：构建图]:
        使用HashMap<Integer, ArrayList<Integer>> 记录节点及其邻接节点(邻接列表是x课程选择后可以选的课程)
        使用 int[] indu 来记录每一门课程对应的入度(入度:具体只上一门必须选择的课程)
[第二步：删除入度为0的节点: 拓扑排序,就是就是广度优先遍历的思想]
        map中存放了所有的节点,indu中存放了所有节点的入度值
        当map不等于空,说明还有课程不能上.下面进行如下步骤循环
        - 1.记录初始map中的节点个数
        - 2.从map中的节点中循环找入度为0的节点:将其邻接节点的入度分别减1
        - 3.将一轮中所有入度为0的点加入 delet表.并在map一轮遍历结束后删除delet表中所有的节点
        - 4.重新统计map中的节点值:
            - 如果跟初始节点值相同:说明没有入度为0的点,图中有环,直接返回false
            - 否则开始下一轮循环:重复1-4的步骤   
```

------

### T210

跟T207一样，不过需要记录拓扑排序后依次遍历的节点

```
[知识点]
拓扑排序
广度优先搜索
hashmap或者队列
入度表

[解题思路]
1.首先构建一张图和一个所有节点的入度表
2.每次从入度表中找到入度为0的点进行删除,并将其邻接点的入度减1

[代码模板]
构建一个hashmap存放图。每一个键表示节点，值表示节点的邻接节点
使用一个数组记录所有节点的入度
使用一个队列，队列中始终存放入度为0的节点。
当队列中没有节点时，判断入度表数组是否全部为0
```

## 最小高度树

**无向图的最小高度树：**

- **定义**：从根到最远叶子节点的边数等于树的高度。而无向无环图中任意一个节点作为根节点对应的树中具有最小高度的那一组树就是图的最小高度树。

- 最多只有两个根节点可以生成最小高度树，并且可以作为根节点的节点必定不是叶节点。
- 解题思路：设立一个点集，保存当前图中度为1的点，即树的叶子结点。然后将这些结点从图中删去，此时，有可能会生成一些新的叶子结点，那么再将这些新的叶子结点加入点集中。不断重复这个过程，直到图中的剩下的点不超过3个。为什么是3个呢？举个例子，假设一个图有两个点，用一条边连起来，那么返回的结果就是这两个点。但如果图中有三个点，用两条边连起来，那么返回的结果就是中间的那一个点。

------

### T310

这道题用一般的DFS和BFS都可以求出答案，但是如果图太大的时候，这两种方法会超时，因此使用下面的解题思路：

- 创建一个点集，每一轮都将图中出度为1的点放入点集
- 最后一轮为点集就是最终的结果

```
【本题思路】
- 创建一个图节点的邻接表、创建一个图节点的出度表
- 初始化这两个表，记录图及节点的出度
- 创建一个队列用于存放所有出度为1的叶子节点
- 初始化队列：将出度表中所有的出度1的叶子加入入队
下面开始循环操作：
- 每一轮开始统计队列中的节点个数，节点个数就是此时子图中最外层叶子节点的个数
- 每一轮都创建新的结果集对象，最后一轮的结果集就是最终结果
- 依次删除这一层的叶子节点，同时：
  -- 将删除的这个节点加入结果集
  -- 逐个将这个节点的相邻节点的出度-1（此节点出度不变）
  -- 逐个判断相邻节点此时出度是否为1：为1加入队列，为下一轮的处理节点
- 上面的操作循环进行，直到队列中没有节点结束
- 返回最后一轮的结果集就是最终根节点

【思考】
- 其实每一轮操作都是在动态调整最小高度树的根节点，
- 最后一组出度为1的节点集就是最终可以作为最小高度树的根节点的结果集

【知识点】
图的最小高度树（根据叶子出度为1，从叶子向根层层访问）
BFS和DFS
无向图的出度表
拓扑排序
```

