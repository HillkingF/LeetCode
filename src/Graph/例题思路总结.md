# 图
## 图的遍历
### T133 克隆图

```
【题目】
给你无向连通图中一个节点的引用，请你返回该图的 深拷贝（克隆）。
图中的每个节点都包含它的值 val（int） 和其邻居的列表。
【测试用例】
输入：adjList = [[2,4],[1,3],[2,4],[1,3]]
输出：[[2,4],[1,3],[2,4],[1,3]]
解释：
图中有 4 个节点。
节点 1 的值是 1，它有两个邻居：节点 2 和 4 。
节点 2 的值是 2，它有两个邻居：节点 1 和 3 。
节点 3 的值是 3，它有两个邻居：节点 2 和 4 。
节点 4 的值是 4，它有两个邻居：节点 1 和 3 。
```

```
/** 【解题思路】
 * 如果传入的节点 无邻接点,则copy值创建对象并返回单节点
 * 如果这个节点在状态表中已经存在: 从map状态表中获取此节点并返回
 * 如果这是一个未被扫描的原节点:
 * - 首先创建一个新节点并 初始化值
 * - 在状态map中存放这个新节点
 * - 创建一个用于存放邻接节点的list. 然后遍历原节点的邻接节点:
 * ===== 邻接节点已经在map中存在,则直接从map邻接节点加入新的list
 * ===== 邻接节点不存在map中,则对这个邻接节点使用BFS进行深拷贝.BFS返回值是这个邻接节点深拷贝后的新节点
 *       将这个新节点也加入新list
 * ===== 原节点的所有邻接节点值都深拷贝并加入 新list后,完成这个原节点的拷贝
 * - 最后返回原节点
 */
 
 【用到的知识点】
 深度优先搜索
 图的定义
 Hashmap根据节点值存放节点，表示已经访问
 邻接表使用List<Node>存放
 也可以使用广度优先搜索[之后试一下:需要用到队列]
```

此外图的定义题目给出：

```java
// 定义节点
class Node {
    public int val;  // 这个节点的值
    public List<Node> neighbors;  //这个节点邻居节点的序号列表
    public Node() {   // 没有值默认为0
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {  // 传递值时创建一个空的邻接列表
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
```

## 拓扑排序

定义：

- 把一个 有向无环图 转成 线性的排序 就叫 **拓扑排序**。

步骤：

- 由AOV网构造拓扑序列的拓扑排序算法主要是循环执行以下两步，直到不存在入度为0的顶点为止。

- (1) 选择一个入度为0的顶点并输出之；

- (2) 从网中删除此顶点及所有[出边](https://baike.baidu.com/item/出边)。

[ ![img](img/adaf2edda3cc7cd9565490a03401213fb80e914a) ](https://baike.baidu.com/pic/拓扑排序/5223807/0/adaf2edda3cc7cd9565490a03401213fb80e914a?fr=lemma&ct=single)

- 循环结束后，若输出的顶点数小于网中的顶点数，则输出“有[回路](https://baike.baidu.com/item/回路/35792)”信息，否则输出的顶点序列就是一种拓扑[序列](https://baike.baidu.com/item/序列/1302588)。 [2] 

### T207

题解：https://leetcode-cn.com/problems/course-schedule/solution/bao-mu-shi-ti-jie-shou-ba-shou-da-tong-tuo-bu-pai-/

怎么判断能否修完所有课？

    BFS 结束时，如果仍有课的入度不为 0，无法被选，完成不了所有课。否则，能找到一种顺序把所有课上完。
    或者：用一个变量 count 记录入列的顶点个数，最后判断 count 是否等于总课程数。

```
【知识点】
拓扑排序
BFS  DFS
hashmap记录点及出度邻接表
```

