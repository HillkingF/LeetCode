# 图
## 图的遍历
### T133 克隆图

```
【题目】
给你无向连通图中一个节点的引用，请你返回该图的 深拷贝（克隆）。
图中的每个节点都包含它的值 val（int） 和其邻居的列表。
【测试用例】
输入：adjList = [[2,4],[1,3],[2,4],[1,3]]
输出：[[2,4],[1,3],[2,4],[1,3]]
解释：
图中有 4 个节点。
节点 1 的值是 1，它有两个邻居：节点 2 和 4 。
节点 2 的值是 2，它有两个邻居：节点 1 和 3 。
节点 3 的值是 3，它有两个邻居：节点 2 和 4 。
节点 4 的值是 4，它有两个邻居：节点 1 和 3 。
```

```
/** 【解题思路】
 * 如果传入的节点 无邻接点,则copy值创建对象并返回单节点
 * 如果这个节点在状态表中已经存在: 从map状态表中获取此节点并返回
 * 如果这是一个未被扫描的原节点:
 * - 首先创建一个新节点并 初始化值
 * - 在状态map中存放这个新节点
 * - 创建一个用于存放邻接节点的list. 然后遍历原节点的邻接节点:
 * ===== 邻接节点已经在map中存在,则直接从map邻接节点加入新的list
 * ===== 邻接节点不存在map中,则对这个邻接节点使用BFS进行深拷贝.BFS返回值是这个邻接节点深拷贝后的新节点
 *       将这个新节点也加入新list
 * ===== 原节点的所有邻接节点值都深拷贝并加入 新list后,完成这个原节点的拷贝
 * - 最后返回原节点
 */
 
 【用到的知识点】
 深度优先搜索
 图的定义
 Hashmap根据节点值存放节点，表示已经访问
 邻接表使用List<Node>存放
 也可以使用广度优先搜索[之后试一下:需要用到队列]
```

此外图的定义题目给出：

```java
// 定义节点
class Node {
    public int val;  // 这个节点的值
    public List<Node> neighbors;  //这个节点邻居节点的序号列表
    public Node() {   // 没有值默认为0
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {  // 传递值时创建一个空的邻接列表
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
```

## 拓扑排序

定义：

- 把一个 有向无环图 转成 线性的排序 就叫 **拓扑排序**。

步骤：

- 由AOV网构造拓扑序列的拓扑排序算法主要是循环执行以下两步，直到不存在入度为0的顶点为止。

- (1) 选择一个入度为0的顶点并输出之；

- (2) 从网中删除此顶点及所有[出边](https://baike.baidu.com/item/出边)。

[ ![img](img/adaf2edda3cc7cd9565490a03401213fb80e914a) ](https://baike.baidu.com/pic/拓扑排序/5223807/0/adaf2edda3cc7cd9565490a03401213fb80e914a?fr=lemma&ct=single)

- 循环结束后，若输出的顶点数小于网中的顶点数，则输出“有[回路](https://baike.baidu.com/item/回路/35792)”信息，否则输出的顶点序列就是一种拓扑[序列](https://baike.baidu.com/item/序列/1302588)。 [2] 

------

### T207

题解：https://leetcode-cn.com/problems/course-schedule/solution/bao-mu-shi-ti-jie-shou-ba-shou-da-tong-tuo-bu-pai-/

怎么判断能否修完所有课？

    BFS 结束时，如果仍有课的入度不为 0，无法被选，完成不了所有课。否则，能找到一种顺序把所有课上完。
    或者：用一个变量 count 记录入列的顶点个数，最后判断 count 是否等于总课程数。

```
【知识点】
拓扑排序
BFS  DFS
hashmap记录点及出度邻接表

【本题的解题思路】
[第一步：构建图]:
        使用HashMap<Integer, ArrayList<Integer>> 记录节点及其邻接节点(邻接列表是x课程选择后可以选的课程)
        使用 int[] indu 来记录每一门课程对应的入度(入度:具体只上一门必须选择的课程)
[第二步：删除入度为0的节点: 拓扑排序,就是就是广度优先遍历的思想]
        map中存放了所有的节点,indu中存放了所有节点的入度值
        当map不等于空,说明还有课程不能上.下面进行如下步骤循环
        - 1.记录初始map中的节点个数
        - 2.从map中的节点中循环找入度为0的节点:将其邻接节点的入度分别减1
        - 3.将一轮中所有入度为0的点加入 delet表.并在map一轮遍历结束后删除delet表中所有的节点
        - 4.重新统计map中的节点值:
            - 如果跟初始节点值相同:说明没有入度为0的点,图中有环,直接返回false
            - 否则开始下一轮循环:重复1-4的步骤   
```

------

### T210

跟T207一样，不过需要记录拓扑排序后依次遍历的节点

```
[知识点]
拓扑排序
广度优先搜索
hashmap或者队列
入度表

[解题思路]
1.首先构建一张图和一个所有节点的入度表
2.每次从入度表中找到入度为0的点进行删除,并将其邻接点的入度减1

[代码模板]
构建一个hashmap存放图。每一个键表示节点，值表示节点的邻接节点
使用一个数组记录所有节点的入度
使用一个队列，队列中始终存放入度为0的节点。
当队列中没有节点时，判断入度表数组是否全部为0
```

